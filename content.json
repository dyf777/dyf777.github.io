[{"title":"并发之线程安全","date":"2020-03-15T03:36:05.000Z","path":"2020/03/15/并发之线程安全/","text":"并发之线程安全1.1、什么时候需要线程安全在需要进行多线程操作时，都会需要保证线程安全 1.2、什么是线程安全当多线程访问某个类时，(无论环境与操作行为)这个类始终都能够表现出正确的行为，那么这个类就是线程安全的。 1.3、什么是无状态既不包含域，也不包含对其它类中域的使用。计算中的临时状态仅存在于线程栈上的局部变量中。(输入与输出的结果均和外界无关)无状态对象一定是线程安全的 1.4、竞态条件由于不恰当的执行时序而产生不正确的结果被称为竞态条件 先检查后执行：基于一种可能失效的结果来进行判断或计算 读取-修改-写入：自增等单目运算符在执行时均会拆分为这三步原子操作 以上二者均属于复合操作 1.5、加锁机制如果一个类中只含有一个状态变量，则可以通过AtomicLong等线程安全的原子操作来进行。但如果有多个状态变量则需要保证如果相互之间有依赖关系，必须在操作其中一个变量时，在原子操作中对其它变量也进行更新。此时AtomicLong等线程安全的对象将不能实现这一点，那么就需要引入加锁机制。 1.5.1、内置锁Java中提供了一种内置的锁机制来支持原子性：同步代码块(Synchronized Block)，一个同步代码块包括：锁引用和锁保护的代码块。以synchronized来修饰的方法相当于横跨整个方法的同步代码块此时以实例化对象做锁，而synchronized修饰的静态代码以该类的Class对象做锁。在访问同步代码块时自动获得锁，在访问完毕退出时自动释放锁 1.5.2、重入锁当某个线程请求获得一个已经由它自己持有的锁，那么将会成功。 12345678910111213class Message&#123; synchronized void send()&#123; &#125;&#125;class HttpMessage extends Message&#123; @Override synchronized void send() &#123; System.out.println(\"send。。。\"); super.send(); &#125;&#125; 如果没有重入锁，那么上面的代码将会发生死锁，因为在调用super.send()时将会被永久阻塞。重入锁其中一种实现方法是，添加一个计数器，请求成功一次计数器加一，一个请求结束后计数器减一，计数器为0时释放锁 此为《Java并发编程实战》读书笔记。若有启发，不胜荣幸；若有谬误，欢迎指正。。","categories":[{"name":"并发","slug":"并发","permalink":"http://dyf777.github.io/categories/并发/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://dyf777.github.io/tags/并发/"}]},{"title":"Shiro学习记录三","date":"2020-02-16T07:45:53.000Z","path":"2020/02/16/Shiro学习记录：会话管理/","text":"Shiro会话管理1、会话1.1、是什么1.2、如何使用2、会话管理器3、会话监听器4、会话存储5、会话验证","categories":[{"name":"Shiro","slug":"Shiro","permalink":"http://dyf777.github.io/categories/Shiro/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://dyf777.github.io/tags/Shiro/"}]},{"title":"Shiro学习记录(二)：授权","date":"2020-02-07T05:22:30.000Z","path":"2020/02/07/Shiro学习记录：授权/","text":"Shiro学习记录(二)：授权授权就是控制谁能够访问哪些资源（页面访问，数据操作等），通过授予不同的权限能够将资源进行精细化的开放。 2.1、关键元素 Subject：主体，即访问应用的用户，在 Shiro 中使用 Subject 代表该用户。用户只有授权后才允许访问相应的资源。 Role：角色，即拥有权限的集合，通常在赋予用户权限时，一般都会给用户赋予某一角色，用户就会拥有这个角色的所有权限，这样的方式也能够更方便的操作 Permission：资源许可，在应用中用户可以访问的任何东西，比如访问 JSP 页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。 2.2、工作流程授权的工作流程图如下： authrity.png 1）应用调用hasRole,,isPermitted 方法，传入任意需要的角色或权限2）Subject实例，本质上是DelegatingSubject通过代理调用应用的 SecurityManager各自的hasRole* ，checkRole* ，isPermitted* ，hasPermission* 方法3）在进行授权之前，其会调用相应的 Realm 获取 Subject 相应的角色/权限用于匹配传入的角色/权限4）Authorizer 会判断 Realm 的角色/权限是否和传入的匹配，如果有多个 Realm，会委托给 ModularRealmAuthorizer 进行循环判断，如果匹配如 isPermitted/hasRole 会返回 true，否则返回 false 表示授权失败。 2.3、权限匹配规则在进行权限匹配时约定有如下规则:”资源标识符：操作：对象实例ID”，其中资源标识符可分为多级，通过“：”隔开，操作包括对资源的增删改查，当有多个操作时通过“，”隔开，“* ”代表通配符，可以匹配任意资源、操作及对象实例。 sys:user:create:1代表当前用户拥有sys:user资源的1实例的增加权限 ::view代表当前用户拥有所有资源的查看权限 2.4、权限验证的方式 编程式通过在Java代码中进行权限校验 123456Subject subject = SecurityUtils.getSubject();if(subject.hasRole(“admin”)) &#123; //有权限&#125; else &#123; //无权限&#125; 注解式通过在方法上标注解，当有admin权限时才能够访问该方法 1234@RequiresRoles(\"admin\")public void hello() &#123; //有权限&#125; 标签式通过使用shiro标签来进行验证，只有拥有该权限时才能够访问该内容注：需要导入shiro标签库 1234&lt;%@ taglib prefix=\"shiro\" uri=\"http://shiro.apache.org/tags\" %&gt;&lt;shiro:hasRole name=\"admin\"&gt;&lt;!— 有权限 —&gt;&lt;/shiro:hasRole&gt; 2.5、自定义授权2.5.1、自定义授权方式通过继承AuthorizingRealm类来完成 2.5.2、自定义授权规则","categories":[],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://dyf777.github.io/tags/Shiro/"}]},{"title":"Shiro学习记录(一):认证","date":"2020-02-06T13:49:44.000Z","path":"2020/02/06/Shiro学习记录：认证/","text":"1、Shiro是什么Shiro是Apache开源的一个轻量级的Java安全框架，它提供了认证、授权、会话管理以及加密等功能，相对于Spring Security来说更加的直观易用，但同时也能够提供健壮的安全性。 2、Shiro的功能与结构2.1、Shiro的功能Shiro的功能结构图如下： struct.png Authentication：身份认证，验证用户是否拥有某个身份； 权限校验，验证某个已认证的用户是否拥有某个权限，确定该用户是否能访问某个资源； 会话管理，管理用户登录后的会话，与HttpSession类似，但它也能够在Java SE应用中使用； 加密，更好的保护数据的安全性； Web 支持，可以非常容易的集成到 Web 环境； 缓存，比如用户登录后，其用户信息不必每次去查，这样可以提高效率； shiro支持多线程并发验证，能够让权限在多个线程中传播； shiro提供了测试支持； 允许当前用户以其它用户的身份来登录； 记住我，将登录信息存储，下次就可以免登录。2.2、Shiro的工作流程Shiro的工作流程图如下： work.png 其中涉及重要的三个部件： Subject：主体，代表了当前正在进行交互的对象 SecurityManager：安全管理器，它是整个框架的核心，其它所有组件都会与它进行交互 Realm：域，Shiro从域中获取安全数据，当验证用户身份时，就需要从Realm中获取数据并进行比对以确定该用户是否合法2.3、Shiro的架构 struct.png 3、认证3.1、认证流程认证流程图解： authentication.png 1)Subject.login(token)通过传入token进行登录，实际会委托给securityManager进行操作，调用前必须通过Security.setSecurityManager(mananger)传入securityManager2)SecuriyManager会将认证工作交给Authenticator进行认证3）Authenticator是进行认证的关键组件，通过调用自身相应的方法进行认证4）Authenticator 可能会委托给相应的 AuthenticationStrategy 进行多 Realm 身份认证，默认为AtLeastOneSuccessfulStrategy策略认证5）Authenticator 会把相应的 token 传入 Realm，从 Realm 获取身份验证信息，如果没有返回或抛出异常表示身份验证失败了。此处可以配置多个 Realm，将按照相应的顺序及策略进行访问。 3.2、Realm3.2.1、自定义Realm 单个Realm通过实现Realm接口进行自定义Realm：123456789101112131415161718192021222324public class MyRealm1 implements Realm &#123; @Override public String getName() &#123; return \"myRealm1\"; &#125; @Override public boolean supports(AuthenticationToken authenticationToken) &#123; return authenticationToken instanceof UsernamePasswordToken; &#125; @Override public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String username = (String) authenticationToken.getPrincipal(); String password = new String((char[]) authenticationToken.getCredentials()); if(!username.equals(\"zhangsan\"))&#123; throw new UnknownAccountException(); &#125; if(!password.equals(\"123\"))&#123; throw new IncorrectCredentialsException(); &#125; return new SimpleAuthenticationInfo(username,password,getName()); &#125;&#125; 通过ini文件进行配置： 12realm1=com.dyf.shiro.realm.MyRealm1securityManager.realms=$realm1 注：ini文件Shiro官方采用的配置文件，类似于properties文件，通过ini文件可以实现属性的自动注入，类似于Spring的bean通过junit进行测试： 12345678910111213141516171819//通过类路径下的ini文件实例化SecurityManager工厂 IniSecurityManagerFactory managerFactory = new IniSecurityManagerFactory(\"classpath:shiro-realm.ini\"); //获取SecurityManager实例 SecurityManager securityManager = managerFactory.getInstance(); //将SecurityManager对象配置进shiro官方提供的静态工具SecurityUtils中 SecurityUtils.setSecurityManager(securityManager); //获得Subject对象 Subject subject = SecurityUtils.getSubject(); //通过用户名和密码构建登录token UsernamePasswordToken token = new UsernamePasswordToken(\"zhangsan\", \"123\"); //进行登录，若登录失败则会抛出AuthenticationException类型的异常(可再进行细分其子异常) try &#123; subject.login(token); &#125; catch (AuthenticationException e)&#123; System.out.println(\"身份验证失败\"); &#125; //通过断言进行测试结果是否符合 Assert.assertEquals(true,subject.isAuthenticated()); subject.logout(); 多个Realm只需要创建出多个Realm，然后通过ini文件进行配置即可1234realm1=com.dyf.shiro.realm.MyRealm1realm2=com.dyf.shiro.realm.MyRealm2realm3=com.dyf.shiro.realm.MyRealm3securityManager.realms=$realm1,$realm3 3.2.2、使用jdbcRealm查看jdbcRealm的源码可以发现，再进行认证时会从users、user_roles、roles_permissions表中查询信息，因此需要创建这些表： 123456789101112131415161718192021222324252627282930drop database if exists shiro;create database shiro;use shiro;create table users ( id bigint auto_increment, username varchar(100), password varchar(100), password_salt varchar(100), constraint pk_users primary key(id)) charset=utf8 ENGINE=InnoDB;create unique index idx_users_username on users(username);create table user_roles( id bigint auto_increment, username varchar(100), role_name varchar(100), constraint pk_user_roles primary key(id)) charset=utf8 ENGINE=InnoDB;create unique index idx_user_roles on user_roles(username, role_name);create table roles_permissions( id bigint auto_increment, role_name varchar(100), permission varchar(100), constraint pk_roles_permissions primary key(id)) charset=utf8 ENGINE=InnoDB;create unique index idx_roles_permissions on roles_permissions(role_name, permission);insert into users(username,password)values('zhang','123'); 同时还需要导入数据库相关依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.40&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.17&lt;/version&gt;&lt;/dependency&gt; 然后通过ini文件进行相关的配置： 123456789[main]jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealmdataSource=com.alibaba.druid.pool.DruidDataSourcedataSource.driverClassName=com.mysql.jdbc.DriverdataSource.url=jdbc:mysql://localhost:3306/shirodataSource.username=rootdataSource.password=123456jdbcRealm.dataSource=$dataSourcesecurityManager.realms=$jdbcRealm 3.3、AuthenticationStrategyAuthenticationStrategy能够指定Realm的验证策略，主要的认证策略包括： FirstSuccessfulStrategy：只要有一个 Realm 验证成功即可，只返回第一个 Realm 身份验证成功的认证信息，其他的忽略； AtLeastOneSuccessfulStrategy：只要有一个 Realm 验证成功即可，和FirstSuccessfulStrategy 不同，返回所有 Realm 身份验证成功的认证信息； AllSuccessfulStrategy：所有 Realm 验证成功才算成功，且返回所有 Realm 身份验证成功的认证信息，如果有一个失败就失败了。 ModularRealmAuthenticator 默认使用 AtLeastOneSuccessfulStrategy 策略。可以通过ini文件进行指定： 1234authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticatorsecurityManager.authenticator=$authenticatorallSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategysecurityManager.authenticator.authenticationStrategy=$allSuccessfulStrategy 同时如果原本提供的验证策略不能够满足需要，也能够自定义验证策略，只需要继承AbstractAuthenticationStrategy抽象类并实现如下方法即可： 1234567891011121314151617181920212223242526272829303132public class AtLeastTwoAuthenticatorStrategy extends AbstractAuthenticationStrategy &#123;//在所有Realm验证之前调用 @Override public AuthenticationInfo beforeAllAttempts(Collection&lt;? extends Realm&gt; collection, AuthenticationToken authenticationToken) throws AuthenticationException &#123; //新建一个认证信息 return new SimpleAuthenticationInfo(); &#125;//在每个Realm之前调用 @Override public AuthenticationInfo beforeAttempt(Realm realm, AuthenticationToken authenticationToken, AuthenticationInfo authenticationInfo) throws AuthenticationException &#123; //将上一个Realm传下来的认证信息返回 return authenticationInfo; &#125;//在每个Realm之后调用 @Override public AuthenticationInfo afterAttempt(Realm realm, AuthenticationToken authenticationToken, AuthenticationInfo authenticationInfo, AuthenticationInfo authenticationInfo1, Throwable throwable) throws AuthenticationException &#123; //若上一个Realm的认证信息和当前Realm的认证信息都不为空则合并，merge()方法由AbstractAuthenticationStrategy提供 AuthenticationInfo info = authenticationInfo; if(authenticationInfo1 != null)&#123; info = merge(authenticationInfo,authenticationInfo1); &#125; return info; &#125;//在所有Realm之后调用 @Override public AuthenticationInfo afterAllAttempts(AuthenticationToken authenticationToken, AuthenticationInfo authenticationInfo) throws AuthenticationException &#123; //判断认证信息数量是否小于2 if(authenticationInfo == null || CollectionUtils.isEmpty(authenticationInfo.getPrincipals()) || authenticationInfo.getPrincipals().getRealmNames().size() &lt; 2) throw new AuthenticationException(); return authenticationInfo; &#125;&#125; 菜鸡记录学习历程，若有纰漏之处，欢迎指正~~","categories":[{"name":"Shiro","slug":"Shiro","permalink":"http://dyf777.github.io/categories/Shiro/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://dyf777.github.io/tags/Shiro/"}]},{"title":"Hexo+Github搭建个人博客","date":"2019-06-30T05:21:00.000Z","path":"2019/06/30/Hexo-Github搭建个人博客/","text":"前言：暗中观察许久之后，终于在B站UP主羊哥（CodeSheep）的启发下决定开始搭建属于自己的博客。对我而言，搭建个人博客可以让咱这种糙汉子记笔记更加细致用心（毕竟迟早都要拿出来见人的），不至于刚学完再看自己的笔记跟看天书似的；同时，对于参加工作的人来说，有一个自己的个人博客绝对是加分大项。 关于Hexo：Hexo是一款基于Node.js的静态博客框架，简单易上手，同时由于其流行度广，所以在使用中遇到的许多问题都可以很容易的找到解决方案。当然，也可以找到非常多酷炫的皮肤。将Hexo生成的静态网页托管在Github上，也可以让其它人很容易就能访问自己的主页。 搭建步骤： 1.本地操作 1.1.安装Git 1.2.安装Node.js 1.3.安装Hexo 1.4.基本用法 2.远程关联 2.1.创建个人仓库 2.2.项目推送 3.个性化设置 1.本地操作1.1.安装GitGit是一款开源的版本控制工具，可以让我们更加高效的管理项目，具体用法可以参看廖雪峰老师的Git教程。首先，需要从Git官网下载安装包并安装，在安装完成后右键菜单中就会集成Git工具。 1.2.安装Node.jsHexo是基于Node.js的博客框架，因此需要其支持。首先需要从Node.js官网下载安装包（后缀为LTS的长期支持版最佳）。在点击安装完成后通过控制台键入node -v以及npm -v出现相应的版本信息就是安装成功。 1.3.安装Hexo创建一个自己的博客文件夹Blog，按住shift键鼠标右击打开Git Bash，使用npm命令安装Hexo： 1npm install -g hexo-cli 通过hexo -v查看是否安装成功。至此，需要安装的东西全部安装完成。 1.4.基本用法在所有安装步骤都完成后，在当前Blog文件夹下进行初始化，在Git Bash中输入 1hexo init 然后在本地启动hexo，输入： 1hexo s 其地址为:localhost:4000。若端口被占用则需要更改端口，通过输入： 1hexo server -p 端口号","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://dyf777.github.io/categories/环境搭建/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://dyf777.github.io/tags/环境搭建/"}]}]