<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Feifei&#39;Blog</title>
  <icon>https://www.gravatar.com/avatar/a37f39a72b5c31b87bb58f6645999826</icon>
  <subtitle>不为圣贤，便为禽兽</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dyf777.github.io/"/>
  <updated>2020-03-15T03:51:42.481Z</updated>
  <id>http://dyf777.github.io/</id>
  
  <author>
    <name>好好先生</name>
    <email>dyuanfei777@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发之线程安全</title>
    <link href="http://dyf777.github.io/2020/03/15/%E5%B9%B6%E5%8F%91%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://dyf777.github.io/2020/03/15/%E5%B9%B6%E5%8F%91%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</id>
    <published>2020-03-15T03:36:05.000Z</published>
    <updated>2020-03-15T03:51:42.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发之线程安全"><a href="#并发之线程安全" class="headerlink" title="并发之线程安全"></a>并发之线程安全</h2><h3 id="1-1、什么时候需要线程安全"><a href="#1-1、什么时候需要线程安全" class="headerlink" title="1.1、什么时候需要线程安全"></a>1.1、什么时候需要线程安全</h3><p>在需要进行多线程操作时，都会需要保证线程安全</p><h3 id="1-2、什么是线程安全"><a href="#1-2、什么是线程安全" class="headerlink" title="1.2、什么是线程安全"></a>1.2、什么是线程安全</h3><p>当多线程访问某个类时，(无论环境与操作行为)这个类始终都能够表现出正确的行为，那么这个类就是线程安全的。</p><h3 id="1-3、什么是无状态"><a href="#1-3、什么是无状态" class="headerlink" title="1.3、什么是无状态"></a>1.3、什么是无状态</h3><p>既不包含域，也不包含对其它类中域的使用。计算中的临时状态仅存在于线程栈上的局部变量中。(输入与输出的结果均和外界无关)<br>无状态对象一定是线程安全的</p><h3 id="1-4、竞态条件"><a href="#1-4、竞态条件" class="headerlink" title="1.4、竞态条件"></a>1.4、竞态条件</h3><p>由于不恰当的执行时序而产生不正确的结果被称为竞态条件</p><ul><li>先检查后执行：基于一种可能失效的结果来进行判断或计算</li><li>读取-修改-写入：自增等单目运算符在执行时均会拆分为这三步原子操作</li><li>以上二者均属于复合操作</li></ul><h3 id="1-5、加锁机制"><a href="#1-5、加锁机制" class="headerlink" title="1.5、加锁机制"></a>1.5、加锁机制</h3><p>如果一个类中只含有一个状态变量，则可以通过AtomicLong等线程安全的原子操作来进行。但如果有多个状态变量则需要保证如果相互之间有依赖关系，必须在操作其中一个变量时，在原子操作中对其它变量也进行更新。此时AtomicLong等线程安全的对象将不能实现这一点，那么就需要引入加锁机制。</p><h4 id="1-5-1、内置锁"><a href="#1-5-1、内置锁" class="headerlink" title="1.5.1、内置锁"></a>1.5.1、内置锁</h4><p>Java中提供了一种内置的锁机制来支持原子性：同步代码块(Synchronized Block)，一个同步代码块包括：锁引用和锁保护的代码块。以synchronized来修饰的方法相当于横跨整个方法的同步代码块此时以实例化对象做锁，而synchronized修饰的静态代码以该类的Class对象做锁。在访问同步代码块时自动获得锁，在访问完毕退出时自动释放锁</p><h4 id="1-5-2、重入锁"><a href="#1-5-2、重入锁" class="headerlink" title="1.5.2、重入锁"></a>1.5.2、重入锁</h4><p>当某个线程请求获得一个已经由它自己持有的锁，那么将会成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpMessage</span> <span class="keyword">extends</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"send。。。"</span>);</span><br><span class="line">        <span class="keyword">super</span>.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有重入锁，那么上面的代码将会发生死锁，因为在调用super.send()时将会被永久阻塞。<br>重入锁其中一种实现方法是，添加一个计数器，请求成功一次计数器加一，一个请求结束后计数器减一，计数器为0时释放锁</p><hr><p>此为《Java并发编程实战》读书笔记。若有启发，不胜荣幸；若有谬误，欢迎指正。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;并发之线程安全&quot;&gt;&lt;a href=&quot;#并发之线程安全&quot; class=&quot;headerlink&quot; title=&quot;并发之线程安全&quot;&gt;&lt;/a&gt;并发之线程安全&lt;/h2&gt;&lt;h3 id=&quot;1-1、什么时候需要线程安全&quot;&gt;&lt;a href=&quot;#1-1、什么时候需要线程安全&quot; cla
      
    
    </summary>
    
    
      <category term="并发" scheme="http://dyf777.github.io/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://dyf777.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Shiro学习记录三</title>
    <link href="http://dyf777.github.io/2020/02/16/Shiro%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/"/>
    <id>http://dyf777.github.io/2020/02/16/Shiro%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/</id>
    <published>2020-02-16T07:45:53.000Z</published>
    <updated>2020-02-20T07:01:11.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shiro会话管理"><a href="#Shiro会话管理" class="headerlink" title="Shiro会话管理"></a>Shiro会话管理</h2><h3 id="1、会话"><a href="#1、会话" class="headerlink" title="1、会话"></a>1、会话</h3><h4 id="1-1、是什么"><a href="#1-1、是什么" class="headerlink" title="1.1、是什么"></a>1.1、是什么</h4><h4 id="1-2、如何使用"><a href="#1-2、如何使用" class="headerlink" title="1.2、如何使用"></a>1.2、如何使用</h4><h3 id="2、会话管理器"><a href="#2、会话管理器" class="headerlink" title="2、会话管理器"></a>2、会话管理器</h3><h3 id="3、会话监听器"><a href="#3、会话监听器" class="headerlink" title="3、会话监听器"></a>3、会话监听器</h3><h3 id="4、会话存储"><a href="#4、会话存储" class="headerlink" title="4、会话存储"></a>4、会话存储</h3><h3 id="5、会话验证"><a href="#5、会话验证" class="headerlink" title="5、会话验证"></a>5、会话验证</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Shiro会话管理&quot;&gt;&lt;a href=&quot;#Shiro会话管理&quot; class=&quot;headerlink&quot; title=&quot;Shiro会话管理&quot;&gt;&lt;/a&gt;Shiro会话管理&lt;/h2&gt;&lt;h3 id=&quot;1、会话&quot;&gt;&lt;a href=&quot;#1、会话&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Shiro" scheme="http://dyf777.github.io/categories/Shiro/"/>
    
    
      <category term="Shiro" scheme="http://dyf777.github.io/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>Shiro学习记录(二)：授权</title>
    <link href="http://dyf777.github.io/2020/02/07/Shiro%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%8E%88%E6%9D%83/"/>
    <id>http://dyf777.github.io/2020/02/07/Shiro%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E6%8E%88%E6%9D%83/</id>
    <published>2020-02-07T05:22:30.000Z</published>
    <updated>2020-02-07T05:34:38.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shiro学习记录-二-：授权"><a href="#Shiro学习记录-二-：授权" class="headerlink" title="Shiro学习记录(二)：授权"></a>Shiro学习记录(二)：授权</h2><p>授权就是控制谁能够访问哪些资源（页面访问，数据操作等），通过授予不同的权限能够将资源进行精细化的开放。</p><h3 id="2-1、关键元素"><a href="#2-1、关键元素" class="headerlink" title="2.1、关键元素"></a>2.1、关键元素</h3><ul><li><p>Subject：主体，即访问应用的用户，在 Shiro 中使用 Subject 代表该用户。用户只有授权后才允许访问相应的资源。</p></li><li><p>Role：角色，即拥有权限的集合，通常在赋予用户权限时，一般都会给用户赋予某一角色，用户就会拥有这个角色的所有权限，这样的方式也能够更方便的操作</p></li><li><p>Permission：资源许可，在应用中用户可以访问的任何东西，比如访问 JSP 页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。</p><h3 id="2-2、工作流程"><a href="#2-2、工作流程" class="headerlink" title="2.2、工作流程"></a>2.2、工作流程</h3><p>授权的工作流程图如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="authrity.png" alt="authrity.png" title>                </div>                <div class="image-caption">authrity.png</div>            </figure><p>1）应用调用hasRole<em>,,isPermitted</em> 方法，传入任意需要的角色或权限<br>2）Subject实例，本质上是DelegatingSubject通过代理调用应用的  SecurityManager各自的hasRole* ，checkRole* ，isPermitted* ，hasPermission* 方法<br>3）在进行授权之前，其会调用相应的 Realm 获取 Subject 相应的角色/权限用于匹配传入的角色/权限<br>4）Authorizer 会判断 Realm 的角色/权限是否和传入的匹配，如果有多个 Realm，会委托给 ModularRealmAuthorizer 进行循环判断，如果匹配如 isPermitted<em>/hasRole</em> 会返回 true，否则返回 false 表示授权失败。</p><h3 id="2-3、权限匹配规则"><a href="#2-3、权限匹配规则" class="headerlink" title="2.3、权限匹配规则"></a>2.3、权限匹配规则</h3><p>在进行权限匹配时约定有如下规则:”资源标识符：操作：对象实例ID”，其中资源标识符可分为多级，通过“：”隔开，操作包括对资源的增删改查，当有多个操作时通过“，”隔开，“* ”代表通配符，可以匹配任意资源、操作及对象实例。</p></li><li><p>sys:user:create:1代表当前用户拥有sys:user资源的1实例的增加权限</p></li><li><p><em>:</em>:view代表当前用户拥有所有资源的查看权限</p><h3 id="2-4、权限验证的方式"><a href="#2-4、权限验证的方式" class="headerlink" title="2.4、权限验证的方式"></a>2.4、权限验证的方式</h3></li><li><p>编程式<br>通过在Java代码中进行权限校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line"><span class="keyword">if</span>(subject.hasRole(“admin”)) &#123;</span><br><span class="line">    <span class="comment">//有权限</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//无权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注解式<br>通过在方法上标注解，当有admin权限时才能够访问该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresRoles</span>(<span class="string">"admin"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//有权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>标签式<br>通过使用shiro标签来进行验证，只有拥有该权限时才能够访问该内容<br>注：需要导入shiro标签库</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">prefix</span>=<span class="string">"shiro"</span> <span class="attr">uri</span>=<span class="string">"http://shiro.apache.org/tags"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasRole</span> <span class="attr">name</span>=<span class="string">"admin"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!—</span> 有权限 —&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasRole</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5、自定义授权"><a href="#2-5、自定义授权" class="headerlink" title="2.5、自定义授权"></a>2.5、自定义授权</h3><h4 id="2-5-1、自定义授权方式"><a href="#2-5-1、自定义授权方式" class="headerlink" title="2.5.1、自定义授权方式"></a>2.5.1、自定义授权方式</h4><p>通过继承AuthorizingRealm类来完成</p><h4 id="2-5-2、自定义授权规则"><a href="#2-5-2、自定义授权规则" class="headerlink" title="2.5.2、自定义授权规则"></a>2.5.2、自定义授权规则</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Shiro学习记录-二-：授权&quot;&gt;&lt;a href=&quot;#Shiro学习记录-二-：授权&quot; class=&quot;headerlink&quot; title=&quot;Shiro学习记录(二)：授权&quot;&gt;&lt;/a&gt;Shiro学习记录(二)：授权&lt;/h2&gt;&lt;p&gt;授权就是控制谁能够访问哪些资源（页面
      
    
    </summary>
    
    
    
      <category term="Shiro" scheme="http://dyf777.github.io/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>Shiro学习记录(一):认证</title>
    <link href="http://dyf777.github.io/2020/02/06/Shiro%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%AE%A4%E8%AF%81/"/>
    <id>http://dyf777.github.io/2020/02/06/Shiro%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%AE%A4%E8%AF%81/</id>
    <published>2020-02-06T13:49:44.000Z</published>
    <updated>2020-02-07T01:27:21.242Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Shiro是什么"><a href="#1、Shiro是什么" class="headerlink" title="1、Shiro是什么"></a>1、Shiro是什么</h3><p>Shiro是Apache开源的一个轻量级的Java安全框架，它提供了认证、授权、会话管理以及加密等功能，相对于Spring Security来说更加的直观易用，但同时也能够提供健壮的安全性。</p><h3 id="2、Shiro的功能与结构"><a href="#2、Shiro的功能与结构" class="headerlink" title="2、Shiro的功能与结构"></a>2、Shiro的功能与结构</h3><h4 id="2-1、Shiro的功能"><a href="#2-1、Shiro的功能" class="headerlink" title="2.1、Shiro的功能"></a>2.1、Shiro的功能</h4><p>Shiro的功能结构图如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="feature.png" alt="struct.png" title>                </div>                <div class="image-caption">struct.png</div>            </figure><ul><li>Authentication：身份认证，验证用户是否拥有某个身份；</li><li>权限校验，验证某个已认证的用户是否拥有某个权限，确定该用户是否能访问某个资源；</li><li>会话管理，管理用户登录后的会话，与HttpSession类似，但它也能够在Java SE应用中使用；</li><li>加密，更好的保护数据的安全性；</li><li>Web 支持，可以非常容易的集成到 Web 环境；</li><li>缓存，比如用户登录后，其用户信息不必每次去查，这样可以提高效率；</li><li>shiro支持多线程并发验证，能够让权限在多个线程中传播；</li><li>shiro提供了测试支持；</li><li>允许当前用户以其它用户的身份来登录；</li><li>记住我，将登录信息存储，下次就可以免登录。<h4 id="2-2、Shiro的工作流程"><a href="#2-2、Shiro的工作流程" class="headerlink" title="2.2、Shiro的工作流程"></a>2.2、Shiro的工作流程</h4>Shiro的工作流程图如下：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="work.png" alt="work.png" title>                </div>                <div class="image-caption">work.png</div>            </figure><p>其中涉及重要的三个部件：</p><ul><li>Subject：主体，代表了当前正在进行交互的对象</li><li>SecurityManager：安全管理器，它是整个框架的核心，其它所有组件都会与它进行交互</li><li>Realm：域，Shiro从域中获取安全数据，当验证用户身份时，就需要从Realm中获取数据并进行比对以确定该用户是否合法<h4 id="2-3、Shiro的架构"><a href="#2-3、Shiro的架构" class="headerlink" title="2.3、Shiro的架构"></a>2.3、Shiro的架构</h4></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="struct.png" alt="struct.png" title>                </div>                <div class="image-caption">struct.png</div>            </figure><h3 id="3、认证"><a href="#3、认证" class="headerlink" title="3、认证"></a>3、认证</h3><h4 id="3-1、认证流程"><a href="#3-1、认证流程" class="headerlink" title="3.1、认证流程"></a>3.1、认证流程</h4><p>认证流程图解：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="authentication.png" alt="authentication.png" title>                </div>                <div class="image-caption">authentication.png</div>            </figure><p>1)Subject.login(token)通过传入token进行登录，实际会委托给securityManager进行操作，调用前必须通过Security.setSecurityManager(mananger)传入securityManager<br>2)SecuriyManager会将认证工作交给Authenticator进行认证<br>3）Authenticator是进行认证的关键组件，通过调用自身相应的方法进行认证<br>4）Authenticator 可能会委托给相应的 AuthenticationStrategy 进行多 Realm 身份认证，默认为AtLeastOneSuccessfulStrategy策略认证<br>5）Authenticator 会把相应的 token 传入 Realm，从 Realm 获取身份验证信息，如果没有返回或抛出异常表示身份验证失败了。此处可以配置多个 Realm，将按照相应的顺序及策略进行访问。</p><h4 id="3-2、Realm"><a href="#3-2、Realm" class="headerlink" title="3.2、Realm"></a>3.2、Realm</h4><h5 id="3-2-1、自定义Realm"><a href="#3-2-1、自定义Realm" class="headerlink" title="3.2.1、自定义Realm"></a>3.2.1、自定义Realm</h5><ul><li>单个Realm<br>通过实现Realm接口进行自定义Realm：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRealm1</span> <span class="keyword">implements</span> <span class="title">Realm</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"myRealm1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(AuthenticationToken authenticationToken)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> authenticationToken <span class="keyword">instanceof</span> UsernamePasswordToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationInfo <span class="title">getAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String username = (String) authenticationToken.getPrincipal();</span><br><span class="line">        String password = <span class="keyword">new</span> String((<span class="keyword">char</span>[]) authenticationToken.getCredentials());</span><br><span class="line">        <span class="keyword">if</span>(!username.equals(<span class="string">"zhangsan"</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!password.equals(<span class="string">"123"</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IncorrectCredentialsException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(username,password,getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通过ini文件进行配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">realm1</span>=com.dyf.shiro.realm.MyRealm1</span><br><span class="line"><span class="attr">securityManager.realms</span>=<span class="variable">$realm1</span></span><br></pre></td></tr></table></figure><p>注：ini文件Shiro官方采用的配置文件，类似于properties文件，通过ini文件可以实现属性的自动注入，类似于Spring的bean<br>通过junit进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过类路径下的ini文件实例化SecurityManager工厂</span></span><br><span class="line">        IniSecurityManagerFactory managerFactory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">"classpath:shiro-realm.ini"</span>);</span><br><span class="line">        <span class="comment">//获取SecurityManager实例</span></span><br><span class="line">        SecurityManager securityManager = managerFactory.getInstance();</span><br><span class="line">        <span class="comment">//将SecurityManager对象配置进shiro官方提供的静态工具SecurityUtils中</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">//获得Subject对象</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//通过用户名和密码构建登录token</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">"zhangsan"</span>, <span class="string">"123"</span>);</span><br><span class="line">        <span class="comment">//进行登录，若登录失败则会抛出AuthenticationException类型的异常(可再进行细分其子异常)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"身份验证失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过断言进行测试结果是否符合</span></span><br><span class="line">        Assert.assertEquals(<span class="keyword">true</span>,subject.isAuthenticated());</span><br><span class="line">        subject.logout();</span><br></pre></td></tr></table></figure><ul><li>多个Realm<br>只需要创建出多个Realm，然后通过ini文件进行配置即可<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">realm1</span>=com.dyf.shiro.realm.MyRealm1</span><br><span class="line"><span class="attr">realm2</span>=com.dyf.shiro.realm.MyRealm2</span><br><span class="line"><span class="attr">realm3</span>=com.dyf.shiro.realm.MyRealm3</span><br><span class="line"><span class="attr">securityManager.realms</span>=<span class="variable">$realm1</span>,<span class="variable">$realm3</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="3-2-2、使用jdbcRealm"><a href="#3-2-2、使用jdbcRealm" class="headerlink" title="3.2.2、使用jdbcRealm"></a>3.2.2、使用jdbcRealm</h5><p>查看jdbcRealm的源码可以发现，再进行认证时会从users、user_roles、roles_permissions表中查询信息，因此需要创建这些表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">exists</span> shiro;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> shiro;</span><br><span class="line"><span class="keyword">use</span> shiro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">bigint</span> auto_increment,</span><br><span class="line">  username <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">  <span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">  password_salt <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">  <span class="keyword">constraint</span> pk_users primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">) <span class="keyword">charset</span>=utf8 <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> idx_users_username <span class="keyword">on</span> <span class="keyword">users</span>(username);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_roles(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">bigint</span> auto_increment,</span><br><span class="line">  username <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">  role_name <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">  <span class="keyword">constraint</span> pk_user_roles primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">) <span class="keyword">charset</span>=utf8 <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> idx_user_roles <span class="keyword">on</span> user_roles(username, role_name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> roles_permissions(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">bigint</span> auto_increment,</span><br><span class="line">  role_name <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">  permission <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">  <span class="keyword">constraint</span> pk_roles_permissions primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">) <span class="keyword">charset</span>=utf8 <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> idx_roles_permissions <span class="keyword">on</span> roles_permissions(role_name, permission);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span>(username,<span class="keyword">password</span>)<span class="keyword">values</span>(<span class="string">'zhang'</span>,<span class="string">'123'</span>);</span><br></pre></td></tr></table></figure><p>同时还需要导入数据库相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.40<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后通过ini文件进行相关的配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[main]</span></span><br><span class="line"><span class="attr">jdbcRealm</span>=org.apache.shiro.realm.jdbc.JdbcRealm</span><br><span class="line"><span class="attr">dataSource</span>=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"><span class="attr">dataSource.driverClassName</span>=com.mysql.jdbc.Driver</span><br><span class="line"><span class="attr">dataSource.url</span>=jdbc:mysql://localhost:<span class="number">3306</span>/shiro</span><br><span class="line"><span class="attr">dataSource.username</span>=root</span><br><span class="line"><span class="attr">dataSource.password</span>=<span class="number">123456</span></span><br><span class="line"><span class="attr">jdbcRealm.dataSource</span>=<span class="variable">$dataSource</span></span><br><span class="line"><span class="attr">securityManager.realms</span>=<span class="variable">$jdbcRealm</span></span><br></pre></td></tr></table></figure><h4 id="3-3、AuthenticationStrategy"><a href="#3-3、AuthenticationStrategy" class="headerlink" title="3.3、AuthenticationStrategy"></a>3.3、AuthenticationStrategy</h4><p>AuthenticationStrategy能够指定Realm的验证策略，主要的认证策略包括： </p><ul><li>FirstSuccessfulStrategy：只要有一个 Realm 验证成功即可，只返回第一个 Realm 身份验证成功的认证信息，其他的忽略；  </li><li>AtLeastOneSuccessfulStrategy：只要有一个 Realm 验证成功即可，和FirstSuccessfulStrategy 不同，返回所有 Realm 身份验证成功的认证信息；  </li><li>AllSuccessfulStrategy：所有 Realm 验证成功才算成功，且返回所有 Realm 身份验证成功的认证信息，如果有一个失败就失败了。</li></ul><p>ModularRealmAuthenticator 默认使用 AtLeastOneSuccessfulStrategy 策略。<br>可以通过ini文件进行指定：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">authenticator</span>=org.apache.shiro.authc.pam.ModularRealmAuthenticator</span><br><span class="line"><span class="attr">securityManager.authenticator</span>=<span class="variable">$authenticator</span></span><br><span class="line"><span class="attr">allSuccessfulStrategy</span>=org.apache.shiro.authc.pam.AllSuccessfulStrategy</span><br><span class="line"><span class="attr">securityManager.authenticator.authenticationStrategy</span>=<span class="variable">$allSuccessfulStrategy</span></span><br></pre></td></tr></table></figure><p>同时如果原本提供的验证策略不能够满足需要，也能够自定义验证策略，只需要继承AbstractAuthenticationStrategy抽象类并实现如下方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtLeastTwoAuthenticatorStrategy</span> <span class="keyword">extends</span> <span class="title">AbstractAuthenticationStrategy</span> </span>&#123;</span><br><span class="line"><span class="comment">//在所有Realm验证之前调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationInfo <span class="title">beforeAllAttempts</span><span class="params">(Collection&lt;? extends Realm&gt; collection, AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">//新建一个认证信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//在每个Realm之前调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationInfo <span class="title">beforeAttempt</span><span class="params">(Realm realm, AuthenticationToken authenticationToken, AuthenticationInfo authenticationInfo)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">//将上一个Realm传下来的认证信息返回</span></span><br><span class="line">        <span class="keyword">return</span> authenticationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//在每个Realm之后调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationInfo <span class="title">afterAttempt</span><span class="params">(Realm realm, AuthenticationToken authenticationToken, AuthenticationInfo authenticationInfo, AuthenticationInfo authenticationInfo1, Throwable throwable)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">//若上一个Realm的认证信息和当前Realm的认证信息都不为空则合并，merge()方法由AbstractAuthenticationStrategy提供</span></span><br><span class="line">        AuthenticationInfo info = authenticationInfo;</span><br><span class="line">        <span class="keyword">if</span>(authenticationInfo1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            info = merge(authenticationInfo,authenticationInfo1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//在所有Realm之后调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationInfo <span class="title">afterAllAttempts</span><span class="params">(AuthenticationToken authenticationToken, AuthenticationInfo authenticationInfo)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">//判断认证信息数量是否小于2</span></span><br><span class="line">        <span class="keyword">if</span>(authenticationInfo == <span class="keyword">null</span> || CollectionUtils.isEmpty(authenticationInfo.getPrincipals()) || authenticationInfo.getPrincipals().getRealmNames().size() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationException();</span><br><span class="line">        <span class="keyword">return</span> authenticationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>菜鸡记录学习历程，若有纰漏之处，欢迎指正~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Shiro是什么&quot;&gt;&lt;a href=&quot;#1、Shiro是什么&quot; class=&quot;headerlink&quot; title=&quot;1、Shiro是什么&quot;&gt;&lt;/a&gt;1、Shiro是什么&lt;/h3&gt;&lt;p&gt;Shiro是Apache开源的一个轻量级的Java安全框架，它提供了认证、授
      
    
    </summary>
    
    
      <category term="Shiro" scheme="http://dyf777.github.io/categories/Shiro/"/>
    
    
      <category term="Shiro" scheme="http://dyf777.github.io/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建个人博客</title>
    <link href="http://dyf777.github.io/2019/06/30/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://dyf777.github.io/2019/06/30/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2019-06-30T05:21:00.000Z</published>
    <updated>2020-01-31T05:30:47.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>暗中观察许久之后，终于在B站UP主羊哥（CodeSheep）的启发下决定开始搭建属于自己的博客。对我而言，搭建个人博客可以让咱这种糙汉子记笔记更加细致用心（毕竟迟早都要拿出来见人的），不至于刚学完再看自己的笔记跟看天书似的；同时，对于参加工作的人来说，有一个自己的个人博客绝对是加分大项。</p><h2 id="关于Hexo："><a href="#关于Hexo：" class="headerlink" title="关于Hexo："></a>关于Hexo：</h2><p>Hexo是一款基于Node.js的静态博客框架，简单易上手，同时由于其流行度广，所以在使用中遇到的许多问题都可以很容易的找到解决方案。当然，也可以找到非常多酷炫的皮肤。将Hexo生成的静态网页托管在Github上，也可以让其它人很容易就能访问自己的主页。</p><h2 id="搭建步骤："><a href="#搭建步骤：" class="headerlink" title="搭建步骤："></a>搭建步骤：</h2><ul><li>1.本地操作<ul><li>1.1.安装Git</li><li>1.2.安装Node.js</li><li>1.3.安装Hexo</li><li>1.4.基本用法</li></ul></li><li>2.远程关联<ul><li>2.1.创建个人仓库</li><li>2.2.项目推送</li></ul></li><li>3.个性化设置</li></ul><h3 id="1-本地操作"><a href="#1-本地操作" class="headerlink" title="1.本地操作"></a>1.本地操作</h3><h4 id="1-1-安装Git"><a href="#1-1-安装Git" class="headerlink" title="1.1.安装Git"></a>1.1.安装Git</h4><p>Git是一款开源的版本控制工具，可以让我们更加高效的管理项目，具体用法可以参看廖雪峰老师的<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程</a>。首先，需要从<a href="https://git-scm.com/" target="_blank" rel="noopener">Git官网</a>下载安装包并安装，在安装完成后右键菜单中就会集成Git工具。</p><h4 id="1-2-安装Node-js"><a href="#1-2-安装Node-js" class="headerlink" title="1.2.安装Node.js"></a>1.2.安装Node.js</h4><p>Hexo是基于Node.js的博客框架，因此需要其支持。首先需要从<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js官网</a>下载安装包（后缀为LTS的长期支持版最佳）。在点击安装完成后通过控制台键入node -v以及npm -v出现相应的版本信息就是安装成功。</p><h4 id="1-3-安装Hexo"><a href="#1-3-安装Hexo" class="headerlink" title="1.3.安装Hexo"></a>1.3.安装Hexo</h4><p>创建一个自己的博客文件夹Blog，按住shift键鼠标右击打开Git Bash，使用npm命令安装Hexo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>通过hexo -v查看是否安装成功。至此，需要安装的东西全部安装完成。</p><h4 id="1-4-基本用法"><a href="#1-4-基本用法" class="headerlink" title="1.4.基本用法"></a>1.4.基本用法</h4><p>在所有安装步骤都完成后，在当前Blog文件夹下进行初始化，在Git Bash中输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>然后在本地启动hexo，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>其地址为:localhost:4000。<br>若端口被占用则需要更改端口，通过输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server -p 端口号</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;&lt;p&gt;暗中观察许久之后，终于在B站UP主羊哥（CodeSheep）的启发下决定开始搭建属于自己的博客。对我而言，搭建个人博客可以让咱这种糙
      
    
    </summary>
    
    
      <category term="环境搭建" scheme="http://dyf777.github.io/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="环境搭建" scheme="http://dyf777.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
</feed>
